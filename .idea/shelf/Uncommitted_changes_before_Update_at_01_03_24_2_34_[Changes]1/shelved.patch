Index: nfa.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by lolikion on 16.02.24.\n//\n#include \"nfa.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"other/linked_list.h\"\n\nNFA *NFA_init(big_int *dim){\n    NFA *a = (NFA *)malloc(sizeof(NFA));\n    if(!a){\n        printf(\"memory allocation error in NFA_init_1\\n\");\n        exit(1);\n    }\n    a->states_cnt=1;\n    a->dim= big_int_copy(dim);\n    a->initial_state=NFA_state_init(a,0);\n    a->initial_state->index=0;\n    a->current_state=a->initial_state;\n    a->states = malloc(sizeof(NFA_state));\n    if(!a->states){\n        printf(\"memory allocation error in NFA_init_2\\n\");\n        exit(1);\n    }\n    a->states[0]=a->initial_state;\n    return a;\n}\n\n\nvoid NFA_add_transition(NFA *a, int state_from, int state_to, big_int *trigger){\n\n    NFA_transition *transition= (NFA_transition *)malloc(sizeof(NFA_transition));\n    if(!transition){\n        printf(\"memory allocation error in NFA_add_transition\\n\");\n        exit(1);\n    }\n    transition->state_from=a->states[state_from];\n    transition->state_to=a->states[state_to];\n    transition->transition_trigger= big_int_copy(trigger);\n    node *curr=(a->states[state_from])->transitions->head;\n\n    if(!curr){\n        (a->states[state_from])->transitions->head=node_init(transition);\n    }\n    else{\n        while(curr->next){\n            if(is_transitions_equal(transition,curr->val)){\n                NFA_transition_free(transition);\n                return;\n            }\n            curr=curr->next;\n        }\n        if(is_transitions_equal(transition,curr->val)){\n            NFA_transition_free(transition);\n            return;\n        }\n        curr->next = node_init(transition);\n    }\n    a->states[state_from]->transitions_cnt++;\n}\n\n\nvoid NFA_remove_transition(NFA *a,int state_from,int state_to,big_int* trigger){\n    node *curr=(a->states[state_from])->transitions->head;\n    node *tmp=NULL;\n    while(curr){\n        if(curr->val->state_from->index==state_from\n        && curr->val->state_to->index==state_to\n        && big_int_equal(curr->val->transition_trigger,trigger)\n        ){\n            if(tmp){\n                tmp->next=curr->next;\n                NFA_transition_free(curr->val);\n                free(curr);\n            }\n            else{\n                (a->states[state_from])->transitions->head=curr->next;\n                NFA_transition_free(curr->val);\n                free(curr);\n            }\n            a->states[state_from]->transitions_cnt--;\n            return;\n        }\n        tmp=curr;\n        curr=curr->next;\n    }\n}\n\n\nint NFA_check(NFA *a,big_int *sentence,int verbose){\n    int accepted=0;\n    big_int *sent2= big_int_copy(sentence);\n\n    if(verbose==1){\n        printf(\"sentence: \");\n        big_int_print(sent2);\n    }\n\n    long max_num_words= (sent2->bit_len)/a->dim->number[0];\n    long processed_words= 0;\n\n    big_int *curr_word= big_int_get(\"0\");\n    big_int *two=big_int_get(\"10\");\n    big_int *dvdr= big_int_lr3(two,a->dim);\n\n    big_int_div2_for_pow(sent2,dvdr,curr_word);\n    big_int_bin_shft_r2(sent2,a->dim->number[0]);\n\n\n    while(processed_words<max_num_words) {\n        node *curr_nd=a->current_state->transitions->head;\n        if(verbose==1) {\n            printf(\"------------------------\\n\");\n            printf(\"not processed part of sentence:\");\n            big_int_print(sent2);\n            printf(\"current word:\");\n            big_int_print(curr_word);\n            printf(\"current state:%d\\n\",a->current_state->index);\n        }\n        while (curr_nd != NULL) {\n            if (big_int_equal(curr_word, curr_nd->val->transition_trigger)) {\n                if(verbose==1){\n                    printf(\"transition from state_%d to state_%d by trigger \",\n                           curr_nd->val->state_from->index,\n                           curr_nd->val->state_to->index);\n                    big_int_print(curr_nd->val->transition_trigger);\n                    printf(\"current state:%d\\n\",curr_nd->val->state_to->index);\n                }\n                a->current_state = curr_nd->val->state_to;\n                break;\n            }\n            curr_nd = curr_nd->next;\n        }\n\n        big_int_div2_for_pow(sent2,dvdr,curr_word);\n        big_int_bin_shft_r2(sent2,a->dim->number[0]);\n        processed_words++;\n\n\n    }\n\n    big_int_free2(4,&sent2,&curr_word,&two,&dvdr);\n\n    accepted=a->current_state->accept_state;\n    a->current_state=a->initial_state;\n    return accepted;\n}\n\n\n\n\nNFA_state *NFA_state_init(NFA *a,int accept_state){\n    NFA_state *state = (NFA_state *)malloc(sizeof(NFA_state));\n    if(!state){\n        printf(\"memory allocation error in state_init1\\n\");\n        exit(1);\n    }\n    state->index=a->states_cnt;\n    state->accept_state=accept_state;\n    state->transitions=malloc(sizeof(struct list));\n    if(!state->transitions){\n        printf(\"memory allocation error in state_init2\\n\");\n        exit(1);\n    }\n    state->transitions->head = NULL;\n    state->transitions_cnt=0;\n    return state;\n}\n\n\nint is_transitions_equal(NFA_transition *tr1,NFA_transition *tr2){\n    if(!tr1 || !tr2){return 0;}\n    return ( (tr1->state_to->index==tr2->state_to->index) && (tr1->state_from->index==tr2->state_from->index) && (big_int_equal(tr1->transition_trigger,tr2->transition_trigger))  );\n}\n\n\nvoid NFA_add_state(NFA *a,NFA_state *state){\n    a->states=realloc(a->states,((a->states_cnt)+1)*sizeof(NFA_state));\n    if(!a->states){\n        printf(\"memory allocation error in NFA_add_state\\n\");\n        exit(1);\n    }\n    a->states_cnt++;\n    a->states[a->states_cnt-1]=state;\n}\n\n\n\nvoid NFA_print(NFA* a){\n    printf(\"automata_states:\\n\\n\");\n    printf(\"--------------------------------------------\\n\");\n    for(int i=0;i<a->states_cnt;i++){\n        printf(\"state_ix=%d; is_acceptable=%d; transitions=%d\\n\",\n               a->states[i]->index,a->states[i]->accept_state,\n               a->states[i]->transitions_cnt\n               );\n        printf(\"   ------transitions-----\\n\");\n        node* curr=a->states[i]->transitions->head;\n        while(curr){\n            printf(\"to=%d; trigger=\",curr->val->state_to->index);\n            big_int_print(curr->val->transition_trigger);\n            curr=curr->next;\n        }\n        printf(\"--------------------------------------------\\n\\n\");\n    }\n}\n\n\n///maybe set to NULL?\nvoid NFA_free(NFA *a){\n    for(int i=0;i<a->states_cnt;i++){\n        NFA_state_free(a->states[i]);\n    }\n    free(a->states);\n    big_int_free(&a->dim);\n    free(a);\n\n}\n\n\n///maybe set to NULL?\nvoid NFA_state_free(NFA_state *s){\n    node_free(s->transitions->head);\n    free(s->transitions);\n    free(s);\n}\n\nvoid NFA_transition_free(NFA_transition *tr){\n    big_int_free(&tr->transition_trigger);\n    free(tr);\n}\n\n\n\n\nvoid NFA_to_dot(NFA *a){\n    FILE *f=fopen(\"../fsm.gv\", \"w\");\n\n    char template[]=\" digraph finite_state_machine {\\n\"\n                    \"\\tfontname=\\\"Helvetica,Arial,sans-serif\\\"\\n\"\n                   \"\\tnode [fontname=\\\"Helvetica,Arial,sans-serif\\\"]\\n\"\n                   \"\\tedge [fontname=\\\"Helvetica,Arial,sans-serif\\\"]\\n\"\n                   \"\\trankdir=LR;\\n\"\n                   \"\\tnode [shape = doublecircle];\";\n\n\n\n\n    fprintf(f,template);\n\n\n    for(int i=0;i<a->states_cnt;i++){\n        if(a->states[i]->accept_state==1){\n             fprintf(f,\" %d\",i);\n        }\n    }\n\n    fprintf(f,\";\\n\\tnode [shape = circle];\\n\");\n\n\n    for(int i=0;i<a->states_cnt;i++){\n        node* curr=a->states[i]->transitions->head;\n\n        while(curr){\n            fprintf(f,\"\\t%d -> %d [label =\\\" \",\n                    curr->val->state_from->index,\n                    curr->val->state_to->index);\n            big_int_fprint(curr->val->transition_trigger,f);\n            fprintf(f,\" \\\"]; \\n\");\n            curr=curr->next;\n        }\n\n    }\n    fprintf(f,\"}   \");\n    fclose(f);\n    system(\"dot -Tpng ../fsm.gv -o ../graph1.png\");\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/nfa.c b/nfa.c
--- a/nfa.c	
+++ b/nfa.c	
@@ -274,7 +274,7 @@
     }
     fprintf(f,"}   ");
     fclose(f);
-    system("dot -Tpng ../fsm.gv -o ../graph1.png");
+    system("dot -Tpng ../fsm.gv -o ../automata1.png");
 }
 
 
Index: main.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by lolikion on 16.02.24.\n//\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"nfa.h\"\n#include \"big_int/big_int.h\"\n\n\nint main(){\n\n    big_int *dim= big_int_get(\"10\");\n\n    big_int *tr1= big_int_get(\"10\");\n    big_int *tr2= big_int_get(\"01\");\n    big_int *tr3= big_int_get(\"11\");\n    big_int *tr4= big_int_get(\"00\");\n\n    big_int *sent= big_int_get(\"001111111101\");\n\n    NFA *nfa=NFA_init(dim);\n\n\n    NFA_add_state(nfa, NFA_state_init(nfa,1));\n    NFA_add_state(nfa, NFA_state_init(nfa,1));\n    NFA_add_state(nfa, NFA_state_init(nfa,0));\n    NFA_add_state(nfa, NFA_state_init(nfa,1));\n    NFA_add_state(nfa, NFA_state_init(nfa,1));\n\n\n    NFA_add_transition(nfa,0,1, tr2);\n    NFA_add_transition(nfa,0,0, tr1);\n    NFA_add_transition(nfa,0,2, tr1);\n    NFA_add_transition(nfa,1,1, tr3);\n    NFA_add_transition(nfa,1,5, tr4);\n    NFA_add_transition(nfa,2,3, tr2);\n    NFA_add_transition(nfa,2,4, tr1);\n\n\n    NFA_to_dot(nfa);\n\n    printf(\"ACCEPTED=%d\",NFA_check(nfa,sent,0));\n\n    NFA_free(nfa);\n\n    big_int_free2(6,&tr1,&tr2,&tr3,&tr4,&dim,&sent);\n\n    return 0;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.c b/main.c
--- a/main.c	
+++ b/main.c	
@@ -34,7 +34,7 @@
     NFA_add_transition(nfa,0,2, tr1);
     NFA_add_transition(nfa,1,1, tr3);
     NFA_add_transition(nfa,1,5, tr4);
-    NFA_add_transition(nfa,2,3, tr2);
+//    NFA_add_transition(nfa,2,3, tr2);
     NFA_add_transition(nfa,2,4, tr1);
 
 
Index: cmake-build-debug/.cmake/api/v1/reply/index-2024-02-16T16-23-34-0513.json
===================================================================
diff --git a/cmake-build-debug/.cmake/api/v1/reply/index-2024-02-16T16-23-34-0513.json b/cmake-build-debug/.cmake/api/v1/reply/index-2024-02-16T16-23-34-0513.json
deleted file mode 100644
--- a/cmake-build-debug/.cmake/api/v1/reply/index-2024-02-16T16-23-34-0513.json	
+++ /dev/null	
@@ -1,108 +0,0 @@
-{
-	"cmake" : 
-	{
-		"generator" : 
-		{
-			"multiConfig" : false,
-			"name" : "Ninja"
-		},
-		"paths" : 
-		{
-			"cmake" : "/snap/clion/265/bin/cmake/linux/x64/bin/cmake",
-			"cpack" : "/snap/clion/265/bin/cmake/linux/x64/bin/cpack",
-			"ctest" : "/snap/clion/265/bin/cmake/linux/x64/bin/ctest",
-			"root" : "/snap/clion/265/bin/cmake/linux/x64/share/cmake-3.27"
-		},
-		"version" : 
-		{
-			"isDirty" : false,
-			"major" : 3,
-			"minor" : 27,
-			"patch" : 8,
-			"string" : "3.27.8",
-			"suffix" : ""
-		}
-	},
-	"objects" : 
-	[
-		{
-			"jsonFile" : "codemodel-v2-e03d23e52e5617d459c5.json",
-			"kind" : "codemodel",
-			"version" : 
-			{
-				"major" : 2,
-				"minor" : 6
-			}
-		},
-		{
-			"jsonFile" : "cache-v2-3512d53c5baa6ad92444.json",
-			"kind" : "cache",
-			"version" : 
-			{
-				"major" : 2,
-				"minor" : 0
-			}
-		},
-		{
-			"jsonFile" : "cmakeFiles-v1-de30772f301b3f4e1de8.json",
-			"kind" : "cmakeFiles",
-			"version" : 
-			{
-				"major" : 1,
-				"minor" : 0
-			}
-		},
-		{
-			"jsonFile" : "toolchains-v1-7096c62e23c342eb06a8.json",
-			"kind" : "toolchains",
-			"version" : 
-			{
-				"major" : 1,
-				"minor" : 0
-			}
-		}
-	],
-	"reply" : 
-	{
-		"cache-v2" : 
-		{
-			"jsonFile" : "cache-v2-3512d53c5baa6ad92444.json",
-			"kind" : "cache",
-			"version" : 
-			{
-				"major" : 2,
-				"minor" : 0
-			}
-		},
-		"cmakeFiles-v1" : 
-		{
-			"jsonFile" : "cmakeFiles-v1-de30772f301b3f4e1de8.json",
-			"kind" : "cmakeFiles",
-			"version" : 
-			{
-				"major" : 1,
-				"minor" : 0
-			}
-		},
-		"codemodel-v2" : 
-		{
-			"jsonFile" : "codemodel-v2-e03d23e52e5617d459c5.json",
-			"kind" : "codemodel",
-			"version" : 
-			{
-				"major" : 2,
-				"minor" : 6
-			}
-		},
-		"toolchains-v1" : 
-		{
-			"jsonFile" : "toolchains-v1-7096c62e23c342eb06a8.json",
-			"kind" : "toolchains",
-			"version" : 
-			{
-				"major" : 1,
-				"minor" : 0
-			}
-		}
-	}
-}
Index: cmake-build-debug/.cmake/api/v1/reply/codemodel-v2-e03d23e52e5617d459c5.json
===================================================================
diff --git a/cmake-build-debug/.cmake/api/v1/reply/codemodel-v2-e03d23e52e5617d459c5.json b/cmake-build-debug/.cmake/api/v1/reply/codemodel-v2-e03d23e52e5617d459c5.json
deleted file mode 100644
--- a/cmake-build-debug/.cmake/api/v1/reply/codemodel-v2-e03d23e52e5617d459c5.json	
+++ /dev/null	
@@ -1,60 +0,0 @@
-{
-	"configurations" : 
-	[
-		{
-			"directories" : 
-			[
-				{
-					"build" : ".",
-					"jsonFile" : "directory-.-Debug-f5ebdc15457944623624.json",
-					"minimumCMakeVersion" : 
-					{
-						"string" : "3.27"
-					},
-					"projectIndex" : 0,
-					"source" : ".",
-					"targetIndexes" : 
-					[
-						0
-					]
-				}
-			],
-			"name" : "Debug",
-			"projects" : 
-			[
-				{
-					"directoryIndexes" : 
-					[
-						0
-					],
-					"name" : "DFA",
-					"targetIndexes" : 
-					[
-						0
-					]
-				}
-			],
-			"targets" : 
-			[
-				{
-					"directoryIndex" : 0,
-					"id" : "NFA::@6890427a1f51a3e7e1df",
-					"jsonFile" : "target-NFA-Debug-1077949905bcb0286130.json",
-					"name" : "NFA",
-					"projectIndex" : 0
-				}
-			]
-		}
-	],
-	"kind" : "codemodel",
-	"paths" : 
-	{
-		"build" : "/home/lolikion/CLionProjects/NFA/cmake-build-debug",
-		"source" : "/home/lolikion/CLionProjects/NFA"
-	},
-	"version" : 
-	{
-		"major" : 2,
-		"minor" : 6
-	}
-}
Index: cmake-build-debug/.cmake/api/v1/reply/target-NFA-Debug-1077949905bcb0286130.json
===================================================================
diff --git a/cmake-build-debug/.cmake/api/v1/reply/target-NFA-Debug-1077949905bcb0286130.json b/cmake-build-debug/.cmake/api/v1/reply/target-NFA-Debug-1077949905bcb0286130.json
deleted file mode 100644
--- a/cmake-build-debug/.cmake/api/v1/reply/target-NFA-Debug-1077949905bcb0286130.json	
+++ /dev/null	
@@ -1,145 +0,0 @@
-{
-	"artifacts" : 
-	[
-		{
-			"path" : "NFA"
-		}
-	],
-	"backtrace" : 1,
-	"backtraceGraph" : 
-	{
-		"commands" : 
-		[
-			"add_executable",
-			"target_link_libraries",
-			"target_include_directories"
-		],
-		"files" : 
-		[
-			"CMakeLists.txt"
-		],
-		"nodes" : 
-		[
-			{
-				"file" : 0
-			},
-			{
-				"command" : 0,
-				"file" : 0,
-				"line" : 7,
-				"parent" : 0
-			},
-			{
-				"command" : 1,
-				"file" : 0,
-				"line" : 13,
-				"parent" : 0
-			},
-			{
-				"command" : 2,
-				"file" : 0,
-				"line" : 14,
-				"parent" : 0
-			}
-		]
-	},
-	"compileGroups" : 
-	[
-		{
-			"compileCommandFragments" : 
-			[
-				{
-					"fragment" : " -march=native -O3 -lm -g -fdiagnostics-color=always"
-				}
-			],
-			"includes" : 
-			[
-				{
-					"backtrace" : 3,
-					"path" : "/home/lolikion/CLionProjects/NFA/."
-				}
-			],
-			"language" : "C",
-			"sourceIndexes" : 
-			[
-				1,
-				2,
-				3
-			]
-		}
-	],
-	"id" : "NFA::@6890427a1f51a3e7e1df",
-	"link" : 
-	{
-		"commandFragments" : 
-		[
-			{
-				"fragment" : "-march=native -O3 -lm -g",
-				"role" : "flags"
-			},
-			{
-				"fragment" : "",
-				"role" : "flags"
-			},
-			{
-				"backtrace" : 2,
-				"fragment" : "-lm",
-				"role" : "libraries"
-			}
-		],
-		"language" : "C"
-	},
-	"name" : "NFA",
-	"nameOnDisk" : "NFA",
-	"paths" : 
-	{
-		"build" : ".",
-		"source" : "."
-	},
-	"sourceGroups" : 
-	[
-		{
-			"name" : "Header Files",
-			"sourceIndexes" : 
-			[
-				0
-			]
-		},
-		{
-			"name" : "Source Files",
-			"sourceIndexes" : 
-			[
-				1,
-				2,
-				3
-			]
-		}
-	],
-	"sources" : 
-	[
-		{
-			"backtrace" : 1,
-			"path" : "nfa.h",
-			"sourceGroupIndex" : 0
-		},
-		{
-			"backtrace" : 1,
-			"compileGroupIndex" : 0,
-			"path" : "big_int/big_int.c",
-			"sourceGroupIndex" : 1
-		},
-		{
-			"backtrace" : 1,
-			"compileGroupIndex" : 0,
-			"path" : "main.c",
-			"sourceGroupIndex" : 1
-		},
-		{
-			"backtrace" : 1,
-			"compileGroupIndex" : 0,
-			"path" : "nfa.c",
-			"sourceGroupIndex" : 1
-		}
-	],
-	"type" : "EXECUTABLE"
-}
Index: fsm.gv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+> digraph finite_state_machine {\n\tfontname=\"Helvetica,Arial,sans-serif\"\n\tnode [fontname=\"Helvetica,Arial,sans-serif\"]\n\tedge [fontname=\"Helvetica,Arial,sans-serif\"]\n\trankdir=LR;\n\tnode [shape = doublecircle]; 1 2 4 5;\n\tnode [shape = circle];\n\t0 -> 1 [label =\" +00000001 \"]; \n\t0 -> 0 [label =\" +00000010 \"]; \n\t0 -> 2 [label =\" +00000010 \"]; \n\t1 -> 1 [label =\" +00000011 \"]; \n\t1 -> 5 [label =\" +00000000 \"]; \n\t2 -> 3 [label =\" +00000001 \"]; \n\t2 -> 4 [label =\" +00000010 \"]; \n}   
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fsm.gv b/fsm.gv
--- a/fsm.gv	
+++ b/fsm.gv	
@@ -5,11 +5,10 @@
 	rankdir=LR;
 	node [shape = doublecircle]; 1 2 4 5;
 	node [shape = circle];
-	0 -> 1 [label =" +00000001 "]; 
-	0 -> 0 [label =" +00000010 "]; 
-	0 -> 2 [label =" +00000010 "]; 
-	1 -> 1 [label =" +00000011 "]; 
-	1 -> 5 [label =" +00000000 "]; 
-	2 -> 3 [label =" +00000001 "]; 
-	2 -> 4 [label =" +00000010 "]; 
+	0 -> 1 [label =" 00000001 "]; 
+	0 -> 0 [label =" 00000010 "]; 
+	0 -> 2 [label =" 00000010 "]; 
+	1 -> 1 [label =" 00000011 "]; 
+	1 -> 5 [label =" 00000000 "]; 
+	2 -> 4 [label =" 00000010 "]; 
 }   
\ No newline at end of file
Index: big_int/big_int.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\n// Created by lolikion on 02.10.23.\n//\n#include <time.h>\n#include <string.h>\n#include \"big_int.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include<math.h>\n#define MAX_BINARY_LENGTH 160000\n#define const1 4\n\n\n\nbig_int *big_int_get(const char *bin_number) {\n    big_int *res = (big_int *) malloc(sizeof(big_int));\n    int bit_len = strlen(bin_number), sign = 0;\n    res->bit_len=bit_len;\n    if (bin_number[0] == '-') {\n        sign = 1;\n        res->sign = '-';\n    } else res->sign = '+';\n    res->length = (bit_len + 7 - sign) >> 3;\n    res->number = (unsigned char *) calloc(res->length, sizeof(res->number[0]));\n    if (res->number == NULL) {\n        printf(\"memory error in big_int_get\\n\");\n        return NULL;\n    }\n    int i;\n    for (i = 0; i < bit_len - sign; i++) {\n        res->number[i / 8] += (bin_number[bit_len - i - 1] - '0') << (i % 8);\n    }\n    big_int_dlz(res);\n    return res;\n}\n\n\nint big_int_equal_sgn(const big_int *n1,const big_int *n2) {\n    if (n1->sign != n2->sign) {\n        return 0;\n    }\n    if (n1->length != n2->length) {\n        return 0;\n    }\n    for (int i = 0; i < n1->length; i++)\n        if ((n1->number[i]) != (n2->number[i])) return 0;\n    return 1;\n}\n\n\nint big_int_equal(const big_int *n1,const big_int *n2) {\n    if (n1->length != n2->length) {\n        return 0;\n    }\n\n    for (int i = 0; i < n1->length; i++)\n        if ((n1->number[i]) != (n2->number[i])) return 0;\n    return 1;\n}\n\n\nvoid big_int_dlz(big_int *n) {\n    int i = (n->length) - 1;\n    while (((i > 0) * (n->number[i] == 0)) != 0) {\n        i--;\n    }\n    if ((n->length) != i + 1) {\n        n->length = i + 1;\n        n->number = (unsigned char *) realloc(n->number, n->length);\n        if (n->number == NULL) {\n            printf(\"memory error in big_int_dlz\\n\");\n        }\n    }\n}\n\n\nvoid big_int_print(const big_int *n) {\n    putchar(n->sign);\n    for (int i = n->length - 1; i > -1; i--) {\n        int x = n->number[i];\n        int bit = 128;\n        for (int j = 7; j > -1; j--) {\n            printf(\"%i\", (x & bit) != 0);\n            bit >>= 1;\n        }\n        if (i)printf(\" \");//REDO\n    }\n    printf(\"\\n\");\n}\n\nvoid big_int_fprint(const big_int *n,FILE *f) {\n    putc(n->sign,f);\n    for (int i = n->length - 1; i > -1; i--) {\n        int x = n->number[i];\n        int bit = 128;\n        for (int j = 7; j > -1; j--) {\n            fprintf(f,\"%i\", (x & bit) != 0);\n            bit >>= 1;\n        }\n        if (i)printf(\" \");//REDO\n    }\n}\n\nvoid big_int_print2(const unsigned int n0, ...) {\n    va_list ptr;\n    va_start(ptr, n0);\n    for (int j = 0; j < n0; j++) {\n        big_int *n = (big_int *) va_arg(ptr, big_int * );\n        putchar(n->sign);\n        for (int i = n->length - 1; i > -1; i--) {\n            int x = n->number[i];\n            int bit = 128;\n            for (int j = 7; j > -1; j--) {\n                printf(\"%i\", (x & bit) != 0);\n                bit >>= 1;\n            }\n//        if (i)printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    va_end(ptr);\n}\n\n\n\n\n\nvoid big_int_swap(big_int *n1, big_int *n2) {\n    char sgn = n1->sign;\n    unsigned int len = n1->length;\n    unsigned char *num = (unsigned char *) calloc(n1->length, sizeof(n1->number[0]));\n    if (num == NULL) {\n        printf(\"memory error in big_int_swap\\n\");\n    }\n    memmove(num, n1->number, n1->length);//ok\n    n1->sign = n2->sign;\n    n1->length = n2->length;\n    n1->number = (unsigned char *) realloc(n1->number, n2->length);\n\n    memmove(n1->number, n2->number, n2->length);\n    n2->sign = sgn;\n    n2->length = len;\n    n2->number = (unsigned char *) realloc(n2->number, len);\n    memmove(n2->number, num, len);\n    free(num);\n}\n\nvoid big_int_swap2(big_int *n1, big_int *n2) {\n    big_int temp = *n1;\n    *n1 = *n2;\n    *n2 = temp;\n}\n\nbig_int *big_int_copy(const big_int *x) {\n    big_int *n3 = (big_int *) malloc(sizeof(big_int));\n    n3->sign = x->sign;\n    n3->bit_len=x->bit_len;\n    n3->length = x->length;\n    n3->number = (unsigned char *) calloc(n3->length, sizeof(x->number[0]));\n    if (n3->number == NULL) {\n        printf(\"memory error in big_int_copy\\n\");\n        return NULL;\n    }\n    memmove(n3->number, x->number, x->length * sizeof(x->number[0]));\n    return n3;\n}\n\n\nint big_int_leq(const big_int *n1,const big_int *n2) //n1<=n2\n{\n    if (n1->length < n2->length) return 1;\n    if (n1->length > n2->length) return 0;\n    for (int i = n1->length - 1; i > -1; i--) {\n        if (n1->number[i] < n2->number[i]) return 1;\n        if (n1->number[i] > n2->number[i]) return 0;\n    }\n    return 1;\n}\n\n\nint big_int_geq(const big_int *n1,const big_int *n2)//n1<=n2\n{\n    if (n1->sign != n2->sign) return (n1->sign == '+') ? 0 : 1;\n    else {\n        if (n1->length < n2->length) return 1 * (n1->sign == '+');\n        if (n1->length > n2->length) return 0 + (n1->sign != '+');\n        for (int i = n1->length; i > -1; i--) {\n            if (n1->number[i] < n2->number[i]) return 1 * (n1->sign == '+');\n            if (n1->number[i] > n2->number[i]) return 0 + (n1->sign != '+');\n        }\n        return 1;\n    }\n}\n\n\nbig_int *big_int_disj(const big_int *n1,const big_int *n2) {\n    int min = (int) fmin(n1->length, n2->length);\n    big_int *n3 = (big_int *) malloc(sizeof(big_int));\n    n3->length = min;\n    n3->number = (unsigned char *) calloc(n3->length, sizeof(n3->number[0]));\n    if (n3->number == NULL) {\n        printf(\"memory error in big_int_disj\\n\");\n        return NULL;\n    }\n    for (int i = 0; i < min; i++) {\n        n3->number[i] = (n2->number[i]) | (n1->number[i]);\n    }\n    n3->sign = '+';\n    big_int_dlz(n3);\n    return n3;\n}\n\n\nvoid big_int_bin_shft_r(big_int *n) {\n    for (int i = 0; i < n->length; i++) {\n        n->number[i] >>= 1;\n        if (i != ((n->length) - 1)) n->number[i] += (((n->number[i + 1])) & 1) << 7;\n    }\n    big_int_dlz(n);\n}\n\n\nvoid big_int_bin_shft_l(big_int *n) {\n    int t = (n->number[(n->length) - 1]) & 128;\n    if (t) {\n        n->length++;\n        n->number = (unsigned char *) realloc(n->number, n->length);\n        if (n->number == NULL) printf(\"memory error in big_int_bin_shft_l\\n\");\n        memset(n->number + (n->length) - 1, 0, 1);\n    }\n    for (int i = n->length - 1; i > -1; i--) {\n        n->number[i] <<= 1;\n        if (i) n->number[i] += (n->number[i - 1] & 128) != 0;\n    }\n}\n\n\nvoid big_int_bin_shft_r2(big_int *n, int cnt) {\n    for (int i = 0; i < (cnt & 7); i++) big_int_bin_shft_r(n);\n    unsigned int x = (cnt >> 3);\n    if (x >= n->length) {\n        free(n->number);\n        n->sign = '+';\n        n->length = 1;\n        n->number = (unsigned char *)  calloc(1, 1);\n    } else {\n        if (x) {\n            n->length -= x;\n            memmove(n->number, n->number + x, sizeof(n->number[0]) * (n->length));\n            n->number = (unsigned char *) realloc(n->number, (n->length) * sizeof(n->number[0]));\n        }\n    }\n    big_int_dlz(n);\n}\n\n\nvoid big_int_bin_shft_l2(big_int *n, unsigned int cnt) {\n    for (int i = 0; i < cnt % 8; i++) big_int_bin_shft_l(n);\n    unsigned int x = cnt / 8;\n    n->length += x;\n    n->number = (unsigned char *) realloc(n->number, (n->length) * sizeof(n->number[0]));\n    if (n->number == NULL) printf(\"memory error in big_int_bin_shft_l2\\n\");\n    memmove(n->number + x, n->number, n->length - x);\n    for (int i = 0; i < x; i++) n->number[i] = 0;\n}\n\n\nvoid big_int_set_bit(big_int *n, long long num, int x) {\n    if ((num / 8) >= (n->length)) {\n        n->number = (unsigned char *) realloc(n->number, (num / 8 + 1) * sizeof(n->number[0]));\n        if (n->number == NULL) printf(\"memory error in big_int_set_bit\\n\");\n        memset((n->number) + (n->length), 0, (num / 8) - (n->length) + 1);\n        n->length = num / 8 + 1;\n    }\n    if (x) { // set bit\n        n->number[num / 8] |= 1 << (num % 8);\n    } else { // clear bit\n        n->number[num / 8] &= ~(1 << (num % 8));\n    }\n    big_int_dlz(n);\n}\n\nvoid big_int_set_bit2(big_int *n, long long num, int x) {\n    if ((num / 8) >= (n->length)) {\n        n->number = (unsigned char *) realloc(n->number, (num / 8 + 1) * sizeof(n->number[0]));\n        if (n->number == NULL) {\n            printf(\"memory error in big_int_set_bit\\n\");\n            return;\n        }\n        memset((n->number) + (n->length), 0, (num / 8) - (n->length) + 1);\n        n->length = num / 8 + 1;\n    }\n    if (x) { // set bit\n        n->number[num / 8] |= 1 << (num % 8);\n    } else { // clear bit\n        n->number[num / 8] &= ~(1 << (num % 8));\n    }\n    big_int_dlz(n);\n}\n\nbig_int *big_int_add(big_int * n1,big_int *n2) {\n    if (n1->sign != n2->sign) {\n        int t = n1->sign == '+';\n        if (t) {\n            n2->sign = '+';\n            big_int *n4 = (big_int_sub(n1, n2));\n            n2->sign = '-';\n            big_int_dlz(n4);\n            return n4;\n        } else {\n            n1->sign = '+';\n            big_int *n4 = (big_int_sub(n2, n1));\n            n1->sign = '-';\n            big_int_dlz(n4);\n            return n4;\n        }\n    }\n    int mx = (int) fmax(n1->length, n2->length), carry = 0, x;\n    big_int *n3 = (big_int *) malloc(sizeof(big_int));\n    n3->length = mx + 1;\n    n3->number = (unsigned char *) calloc(n3->length, sizeof(n3->number[0]));\n    if (n3->number == NULL) { printf(\"memory error in big_int_add\\n\"); }\n    int t = n1->length <= n2->length;\n    if (t) big_int_swap2(n1, n2);\n    for (int i = 0; i < mx; i++) {\n        if (i < n2->length) x = n1->number[i] + n2->number[i] + carry;\n        else x = n1->number[i] + carry;\n        n3->number[i] = x & 0xFF;\n        carry = x >> 8;\n    }\n    if (t) big_int_swap2(n1, n2);\n    n3->number[mx] = carry;\n    n3->sign = n1->sign;\n    big_int_dlz(n3);\n    return n3;\n}\n\n\nvoid big_int_add2(big_int *n1, big_int *n2) {\n    if (n1->sign != n2->sign) {\n        int t = n1->sign == '+';\n        if (t) {\n            n2->sign = '+';\n            big_int *n4 = (big_int_sub(n1, n2));\n            n2->sign = '-';\n            n1->sign = n4->sign;\n            n1->length = n4->length;\n            n1->number=(unsigned char*) realloc(n1->number,n4->length);\n            memmove(n1->number, n4->number, n4->length);\n            big_int_free(&n4);\n            big_int_dlz(n1);\n        } else {\n            n1->sign = '+';\n            big_int *n4 = (big_int_sub(n2, n1));\n            n1->sign = '-';\n            n1->sign = n4->sign;\n            n1->length = n4->length;\n            n1->number=(unsigned char*) realloc(n1->number,n4->length);\n            memmove(n1->number, n4->number, n4->length);\n            big_int_free(&n4);\n            big_int_dlz(n1);\n        }\n    } else {\n        int mx = (int) fmax(n1->length, n2->length), carry = 0, x;\n        big_int *n3 = (big_int *) malloc(sizeof(big_int));\n        n3->length = mx + 1;\n        n3->number = (unsigned char *) calloc(n3->length, sizeof(n3->number[0]));\n        if (n3->number == NULL) { printf(\"memory error in big_int_add2\\n\"); }\n        int t = n1->length <= n2->length;\n        if (t) big_int_swap2(n1, n2);\n        for (int i = 0; i < mx; i++) {\n            if (i < n2->length) x = n1->number[i] + n2->number[i] + carry;\n            else x = n1->number[i] + carry;\n            n3->number[i] = x & 0xFF;\n            carry = x >> 8;\n        }\n        if (t) big_int_swap2(n1, n2);\n        n3->number[mx] = carry;\n        n3->sign = n1->sign;\n        big_int_dlz(n3);\n        n1->length = n3->length;\n        n1->number=(unsigned char*) realloc(n1->number,n3->length);\n        memmove(n1->number, n3->number, n3->length);\n        big_int_free(&n3);\n    }\n}\n\n\nbig_int *big_int_sub(big_int *n1, big_int *n2) {\n    if (n1->sign != n2->sign) {\n        if (n1->sign == '+') {\n            n2->sign = '+';\n            big_int *n4 = (big_int_add(n1, n2));\n            big_int_dlz(n4);\n            n2->sign = '-';\n            return n4;\n        } else {\n            n2->sign = '-';\n            big_int *n4 = (big_int_add(n2, n1));\n            big_int_dlz(n4);\n            n2->sign = '+';\n            return n4;\n        }\n    }\n    int mx = (int) fmax(n1->length, n2->length), carry = 0;\n    big_int *n3 = (big_int *) malloc(sizeof(big_int));\n    n3->length = mx;\n    n3->number = (unsigned char *) calloc(n3->length, sizeof(n3->number[0]));\n    if (n3->number == NULL) { printf(\"memory error in big_int_sub\\n\"); }\n    int t = big_int_leq(n1, n2);\n    if (t)big_int_swap2(n1, n2);\n    for (int i = 0; i < mx; i++) {\n        if (i < n2->length) {\n            if (n1->number[i] > n2->number[i]) {\n                n3->number[i] = n1->number[i] - n2->number[i] - carry;\n                carry = 0;\n            }\n            if (n1->number[i] == n2->number[i]) {\n                if (carry) {\n                    n3->number[i] = 0xFF;\n                } else {\n                    n3->number[i] = 0;\n                }\n            }\n            if (n1->number[i] < n2->number[i]) {\n                if (carry) {\n                    n3->number[i] = 0xFF + n1->number[i] - n2->number[i];\n                } else {\n                    n3->number[i] = 0x100 + n1->number[i] - n2->number[i];\n                    carry = 1;\n                }\n            }\n        } else {\n            if (carry) {\n                if (n1->number[i]) {\n                    n3->number[i] = n1->number[i] - 1;\n                    carry = 0;\n                } else {\n                    n3->number[i] = 0xFF;\n                }\n            } else {\n                n3->number[i] = n1->number[i];\n            }\n        }\n    }\n    if (t) big_int_swap2(n1, n2);\n    if (n1->sign == '+') {\n        if (t)n3->sign = '-';\n        else n3->sign = '+';\n    } else {\n        if (t)n3->sign = '+';\n        else n3->sign = '-';\n    }\n    big_int_dlz(n3);\n    return n3;\n}\n\n\nvoid big_int_sub2(big_int *n1, big_int *n2) {\n    if (n1->sign != n2->sign) {\n        if (n1->sign == '+') {\n            n2->sign = '+';\n            big_int *n4 = (big_int_add(n1, n2));\n            n2->sign = '-';\n            n1->sign = n4->sign;\n            n1->length = n4->length;\n            n1->number=(unsigned char*) realloc(n1->number,n4->length);\n            memmove(n1->number, n4->number, n4->length);\n            big_int_free(&n4);\n            big_int_dlz(n1);\n        } else {\n            n2->sign = '-';\n            big_int *n4 = (big_int_add(n2, n1));\n            n2->sign = '+';\n            n1->sign = n4->sign;\n            n1->length = n4->length;\n            n1->number=(unsigned char*) realloc(n1->number,n4->length);\n            memmove(n1->number, n4->number, n4->length);\n            big_int_free(&n4);\n            big_int_dlz(n1);\n        }\n    } else {\n        int mx = (int) fmax(n1->length, n2->length), carry = 0;\n        big_int *n3 = (big_int *) malloc(sizeof(big_int));\n        n3->length = mx;\n        n3->number = (unsigned char *) calloc(n3->length, sizeof(n3->number[0]));\n        if (n3->number == NULL) { printf(\"memory error in big_int_sub2\\n\"); }\n        int t = big_int_leq(n1, n2);\n        if (t)big_int_swap2(n1, n2);\n        for (int i = 0; i < mx; i++) {\n            if (i < n2->length) {\n                if (n1->number[i] > n2->number[i]) {\n                    n3->number[i] = n1->number[i] - n2->number[i] - carry;\n                    carry = 0;\n                }\n                if (n1->number[i] == n2->number[i]) {\n                    if (carry) {\n                        n3->number[i] = 0xFF;\n                    } else {\n                        n3->number[i] = 0;\n                    }\n                }\n                if (n1->number[i] < n2->number[i]) {\n                    if (carry) {\n                        n3->number[i] = 0xFF + n1->number[i] - n2->number[i];\n                    } else {\n                        n3->number[i] = 0x100 + n1->number[i] - n2->number[i];\n                        carry = 1;\n                    }\n                }\n            } else {\n                if (carry) {\n                    if (n1->number[i]) {\n                        n3->number[i] = n1->number[i] - 1;\n                        carry = 0;\n                    } else {\n                        n3->number[i] = 0xFF;\n                    }\n                } else {\n                    n3->number[i] = n1->number[i];\n                }\n            }\n        }\n        if (t) big_int_swap2(n1, n2);\n        if (n1->sign == '+') {\n            if (t)n3->sign = '-';\n            else n3->sign = '+';\n        } else {\n            if (t)n3->sign = '+';\n            else n3->sign = '-';\n        }\n        big_int_dlz(n3);\n        n1->sign = n3->sign;\n        n1->length = n3->length;\n        n1->number=(unsigned char*) realloc(n1->number,n3->length);\n        memmove(n1->number, n3->number, n3->length);\n        big_int_free(&n3);\n    }\n}\n\n\nbig_int *big_int_euclid_binary(const big_int *x, const big_int *y) {\n    big_int *zero = big_int_get(\"0\");\n    int k, n = 0;\n    big_int *x0 = big_int_copy(x);\n\n    big_int *y0 = big_int_copy(y);\n    x0->sign='+';\n    y0->sign='+';\n    big_int *a = big_int_disj(x0, y0);\n\n    if (!big_int_equal(a, zero)) {\n        while ((a->number[0] & 1) != 1) {\n            big_int_bin_shft_r(a);\n            big_int_bin_shft_r(x0);\n            big_int_bin_shft_r(y0);\n            n++;\n        }\n    }\n\n    while ((!big_int_leq(x0, zero)) && (!big_int_leq(y0, zero))) {\n        if ((x0->number[0] & 1) == 1) {\n            while ((y0->number[0] & 1) == 0) big_int_bin_shft_r(y0);\n        } else {\n            while ((x0->number[0] & 1) == 0) big_int_bin_shft_r(x0);\n        }\n        if (big_int_leq(y0, x0)) {\n            big_int_sub2(x0, y0);\n        } else {\n            big_int_sub2(y0, x0);\n        }\n    }\n\n    big_int *n3 = big_int_add(x0, y0);\n    big_int_bin_shft_l2(n3, n);\n    big_int_free2(4, &x0, &y0, &a, &zero);\n    return n3;\n}\n\n\nbig_int *big_int_mul(const big_int *n1,const big_int *n2) {\n\n    unsigned int new_length = n1->length + n2->length;\n\n    big_int *result = (big_int *) malloc(sizeof(big_int));\n    if (!result) return NULL;\n    result->length = new_length;\n\n    result->number = (unsigned char *) calloc(result->length, sizeof(unsigned char));\n\n    for (size_t i = 0; i < n1->length; i++) {\n        for (size_t j = 0; j < n2->length; j++) {\n            unsigned short mult = n1->number[i] * n2->number[j];\n            unsigned short carry = (result->number[i + j] + mult) >> 8;\n            result->number[i + j] += mult;\n            int k = 1;\n            while (carry) {\n                unsigned short carry2 = (result->number[i + j + k] + carry) >> 8;\n                result->number[i + j + k] += carry;\n                carry = carry2;\n                k++;\n            }\n        }\n    }\n    result->sign = n1->sign != n2->sign ? '-' : '+';\n    big_int_dlz(result);\n    return result;\n}\n\n\nvoid big_int_div2(const big_int *n1, big_int *n2, big_int *res1, big_int *rmdr) {\n    big_int *r = big_int_get(\"0\");\n    big_int *q = big_int_get(\"0\");\n    for (int i = (n1->length) - 1; i >= 0; i--) {\n        for (int bit = 7; bit >= 0; bit--) {\n            big_int_bin_shft_l(r);\n            r->number[0] |= ((n1->number[i]) & (1 << bit)) != 0;\n            if (big_int_leq(n2, r)) {\n                r->sign = '+';\n                big_int_sub2(r, n2);\n                big_int_set_bit(q, i * 8 + bit, 1);\n            }\n        }\n    }\n    res1->sign = (n1->sign == n2->sign) ? '+' : '-';\n    res1->length = q->length;\n    res1->number = (unsigned char *) realloc(res1->number, res1->length);\n    memmove(res1->number, q->number, q->length);\n    rmdr->sign = '+';\n    rmdr->length = r->length;\n    rmdr->number = (unsigned char *) realloc(rmdr->number, rmdr->length);\n    memmove(rmdr->number, r->number, r->length);\n    big_int_free2(2,&r, &q);\n}\n\n\nvoid big_int_div3(const big_int *n1, big_int *n2, big_int *res1) {\n    big_int *r = big_int_get(\"0\");\n    big_int_div2(n1,n2,res1,r);\n    big_int_free(&r);\n}\n\nvoid big_int_rem(const big_int *n1, big_int *n2, big_int *rem) {\n    big_int *q = big_int_get(\"0\");\n    big_int_div2(n1,n2,q,rem);\n    big_int_free(&q);\n}\n\nvoid big_int_div2_for_pow(const big_int *n1, big_int *n2, big_int *rmdr) {\n    big_int *r = big_int_get(\"0\");\n    for (int i = (n1->length) - 1; i >= 0; i--) {\n        for (int bit = 7; bit >= 0; bit--) {\n            big_int_bin_shft_l(r);\n            r->number[0] |= ((n1->number[i]) & (1 << bit)) != 0;\n            if (big_int_leq(n2, r)) {\n                r->sign = '+';\n                big_int_sub2(r, n2);\n            }\n        }\n    }\n    rmdr->sign = '+';\n    rmdr->length = r->length;\n\n    rmdr->number = (unsigned char *) realloc(rmdr->number, rmdr->length);\n    memmove(rmdr->number, r->number, r->length);\n    big_int_free(&r);\n}\n\nbig_int *big_int_rl_mod_pow(const big_int *x,const big_int *n,const big_int *m) {\n    big_int *ans = big_int_get(\"1\");\n    big_int *zero = big_int_get(\"0\");\n    big_int *x0 = big_int_copy(x);\n    big_int *n0 = big_int_copy(n);\n    big_int *m0 = big_int_copy(m);\n    big_int *n4;\n    big_int *xmodm;\n    big_int *sq;\n    while (!big_int_leq(n0, zero)) {\n        if ((n0->number[0]) & 1) {\n            xmodm = big_int_get(\"0\");\n            big_int_div2_for_pow(x0, m0, xmodm);\n            n4 = big_int_mul(ans, xmodm);\n            big_int_swap2(ans, n4);\n            big_int_free(&n4);\n            big_int_free(&xmodm);\n        }\n        sq = big_int_mul(x0, x0);\n        big_int_div2_for_pow(sq, m0, x0);\n        big_int_bin_shft_r(n0);//n>>=1\n        big_int_free(&sq);\n    }\n    big_int_div2_for_pow(ans, m0, ans);\n    big_int_free2(4, &zero, &x0, &m0, &n0);\n    return ans;\n}\n\n\nbig_int *big_int_rl_mod_pow2(const big_int *x,const big_int *n,const big_int *m) {\n    big_int *ans = big_int_get(\"1\");\n    big_int *zero = big_int_get(\"0\");\n    big_int *x0 = big_int_copy(x);\n    big_int *n0 = big_int_copy(n);\n    big_int *m0 = big_int_copy(m);\n    big_int *n4;\n    big_int *xmodm;\n    big_int *sq;\n    while (!big_int_leq(n0, zero)) {\n        if ((n0->number[0]) & 1) {\n            xmodm = big_int_get(\"0\");\n            big_int_div2_for_pow(x0, m0, xmodm);\n            n4 = big_int_karatsuba_mult2(ans, xmodm);\n            big_int_swap2(ans, n4);\n            big_int_free(&n4);\n            big_int_free(&xmodm);\n        }\n        sq = big_int_karatsuba_mult2(x0, x0);\n        big_int_div2_for_pow(sq, m0, x0);\n        big_int_bin_shft_r(n0);//n>>=1\n        big_int_free(&sq);\n    }\n    big_int_div2_for_pow(ans, m0, ans);\n    big_int_free2(4,& zero, &x0, &m0,&n0);\n    return ans;\n}\n\n\nbig_int *big_int_lr_mod_pow(const big_int *x,const big_int *n,big_int *m) {\n    big_int *n3 = big_int_get(\"1\");\n    big_int *sq;\n    big_int *mul;\n    big_int *mul2;\n    for (int i = n->length - 1; i > -1; i--) {\n        for (int j = 7; j > -1; j--) {\n            sq = big_int_mul(n3, n3);\n            big_int_div2_for_pow(sq, m, n3);\n            big_int_free(&sq);\n            if ((n->number[i]) & (1 << j)) {\n                mul = big_int_get(\"0\");\n                big_int_div2_for_pow(x, m, mul);\n                mul2 = big_int_mul(n3, mul);\n                big_int_swap2(mul2, n3);\n                big_int_free(&mul);\n                big_int_free(&mul2);\n            }\n        }\n    }\n    big_int_div2_for_pow(n3, m, n3);\n    return n3;\n}\n\n\nbig_int *big_int_lr_mod_pow2(const big_int *x,const big_int *n, big_int *m) {\n    big_int *n3 = big_int_get(\"1\");\n    big_int *sq;\n    big_int *mul;\n    big_int *mul2;\n    for (int i = n->length - 1; i > -1; i--) {\n        for (int j = 7; j > -1; j--) {\n            big_int_div2_for_pow(n3, m, n3);\n            sq = big_int_karatsuba_mult2(n3, n3);\n            big_int_div2_for_pow(sq, m, n3);\n            big_int_free(&sq);\n            if ((n->number[i]) & (1 << j)) {\n                mul = big_int_get(\"0\");\n                big_int_div2_for_pow(x, m, mul);\n                mul2 = big_int_karatsuba_mult2(n3, mul);\n                big_int_swap2(mul2, n3);\n                big_int_free(&mul);\n                big_int_free(&mul2);\n            }\n        }\n    }\n    big_int_div2_for_pow(n3, m, n3);\n    return n3;\n}\n\nbig_int *big_int_lr3(const big_int *x,const big_int *n) {\n    big_int *n3 = big_int_get(\"1\");\n    big_int *sq;\n    big_int *mul2;\n    for (int i = n->length - 1; i > -1; i--) {\n        for (int j = 7; j > -1; j--) {\n\n            sq = big_int_karatsuba_mult2(n3, n3);\n            big_int_swap2(sq,n3);//n3=sq\n            big_int_free(&sq);\n            if ((n->number[i]) & (1 << j)) {\n                mul2 = big_int_karatsuba_mult2(n3, x);//mul2=n3*mul\n                big_int_swap2(mul2, n3);//n3=mul2\n                big_int_free(&mul2);\n            }\n        }\n    }\n//    big_int_div2_for_pow(n3, m, n3);\n    return n3;\n}\n\nbig_int *big_int_slice(const big_int *n1, long l1, long l2) {\n    big_int *n = (big_int *) malloc(sizeof(big_int));\n    n->sign = n1->sign;\n    n->length = (unsigned int) (l2 - l1 + 1);\n    if (l2 >= n1->length) {\n        n->length = (unsigned int) (n1->length - l1);\n    }\n    if (l1 >= n1->length) {\n        n->length = 1;\n        n->number = (unsigned char *)  calloc(1, sizeof(n1->number[0]));\n        return n;\n    }\n    n->number =(unsigned char *)  calloc(n->length, sizeof(n1->number[0]));\n    memcpy(n->number, n1->number + l1, n->length);\n    big_int_dlz(n);\n    return n;\n}\n\n\nbig_int *big_int_karatsuba_mult2(const big_int *n1,const big_int *n2) {\n    if (n1->length + n2->length <= const1) { return big_int_mul(n1, n2); }\n    else {\n        unsigned int mx = (n1->length >= n2->length) ? n1->length : n2->length;\n        mx += (mx & 1);\n\n        big_int *q = big_int_slice(n1, 0, mx / 2 - 1);\n        big_int *p = big_int_slice(n1, mx / 2, mx - 1);\n        big_int *s = big_int_slice(n2, 0, mx / 2 - 1);\n        big_int *r = big_int_slice(n2, mx / 2, mx - 1);\n\n        big_int *pr = big_int_karatsuba_mult2(p, r);//A1\n        big_int *qs = big_int_karatsuba_mult2(q, s);//A2\n\n        big_int *sm1 = big_int_add(p, q);\n        big_int *sm2 = big_int_add(r, s);\n\n        big_int *a3 = big_int_karatsuba_mult2(sm1, sm2);//A3=(p+q)(r+s)\n        big_int *sm3 = big_int_add(pr, qs);\n\n        big_int_sub2(a3, sm3);//A3=(p+q)(r+s)-pr-qs=ps+qr\n\n        big_int_bin_shft_l2(pr, mx << 3);//A1<<n\n        big_int_bin_shft_l2(a3, mx << 2);//A3=(A3-(A1+A2))<<n/2\n\n\n        big_int *res = big_int_add(pr, a3);\n//        big_int_print(res);\n//        printf(\"228\\n\");\n        big_int_add2(res, qs);//A1<<n + (A3-(A1+A2))<<n/2 + A2\n//        big_int_print(q);big_int_print(p);\n//        big_int_print(r);big_int_print(s);\n//        big_int_print(pr);big_int_print(qs);\n//        big_int_print(a3);big_int_print(sm1);\n//        big_int_print(sm2);big_int_print(sm3);\n//        big_int_print(res);\n//        big_int_print2(11, &q, &p, &r, &s, &pr, &qs, &a3, &sm1, &sm2, &sm3,&res);\n//        printf(\"---------------------\\n\");\n\n\n        big_int_free2(10, &q, &p, &r, &s, &pr, &qs, &a3, &sm1, &sm2, &sm3);\n        return res;\n    }\n}\n\n\nbig_int *big_int_rnd(unsigned int n) {\n    big_int *res = (big_int *) malloc(sizeof(big_int));\n    res->length = n;\n    res->sign = '+';\n    res->number = (unsigned char *) calloc(n, sizeof(unsigned char));\n    for (long i = 0; i < n; i++) {\n        res->number[i] = rand();\n    }\n    if (!((res->number[0]) & 1)) {\n        res->number[0]++;\n    }\n    if (!(res->number[(res->length) - 1])) {\n        res->number[(res->length) - 1]++;\n    }\n\n    return res;\n}\n\nvoid big_int_free(big_int **n) {\n    free((*n)->number);\n    free(*n);\n    *n=NULL;\n}\n\nvoid big_int_free2(const unsigned int n0, ...) {\n    va_list ptr;\n    va_start(ptr, n0);\n    for (int j = 0; j < n0; j++) {\n        big_int **n = va_arg(ptr, big_int ** );\n        if((*n)){\n            big_int_free(n);}\n    }\n    va_end(ptr);\n}\n\nint big_int_primality_test(big_int *n, unsigned int tst_cnt) {\n    long cnt_of_two = 0;\n    int fl = 0;\n    big_int *one = big_int_get(\"1\");\n    big_int *two = big_int_get(\"10\");\n    if(big_int_equal(one,n)){return 0;}\n    if(big_int_equal(two,n)){return 1;}\n\n    big_int *r2 = big_int_sub(n, one);\n    big_int *d = big_int_copy(r2);\n\n    while ((d->number[0] & 1) != 1) {\n        big_int_bin_shft_r(d);\n        cnt_of_two++;\n    }\n\n\n    big_int *r = big_int_sub(n, two);\n    big_int *a=big_int_get(\"0\");\n    big_int *x= big_int_get(\"0\");\n    big_int *y= big_int_get(\"0\");\n\n    for (unsigned int i = 1; i < tst_cnt + 1; i++) {\n\n        if (n->length != 1) { big_int_free2(1,&a); a = big_int_rnd(1 + rand() % ((n->length) - 1)); }//[0;len-1]\n        else { big_int_free2(1,&a); a = big_int_rnd(1);a->number[0]=(2+rand())%((n->number[0])-2); }\n\n        if (big_int_leq(a, one)) {\n            big_int_add2(a, two);\n        }\n\n\n        big_int_free2(1,&x);\n        x = big_int_lr_mod_pow2(a, d, n);\n\n        if (big_int_equal(x, one) || big_int_equal(x, r2)) { continue; }\n\n        for (long i = 1; i < cnt_of_two + 1; i++) {\n\n            big_int_free2(1,&y);\n            y = big_int_karatsuba_mult2(x, x);\n            big_int_div2_for_pow(y, n, y);\n\n            if ((big_int_equal(y, one)) && (!big_int_equal(x, one)) && (!big_int_equal(x, r2))) {\n                big_int_free2(8, &one, &r, &r2, &x, &a, &y, &two, &d);\n                return 0;\n            }\n\n            big_int_swap(x, y);\n        }\n\n        if (!big_int_equal(x, one)) {\n            big_int_free2(8, &one, &r, &r2, &a, &x, &two, &d,&y);\n            return 0;\n        }\n\n        big_int_free2(2, &x, &a);\n    }\n    big_int_free2(8,&a,&one, &r, &r2, &two, &d,&y,&x);\n    return 1;\n}\n\n\nbig_int *big_int_get_prime(unsigned int len, unsigned int tst_cnt) {\n    int prime = 0;\n    big_int *res;\n    //first 100 primes\n    while (!prime) {\n        res = big_int_rnd(len);\n//        printf(\"%li\\n\", clock()/CLOCKS_PER_SEC );\n        prime = big_int_primality_test(res, tst_cnt);\n        if (prime)return res;\n        big_int_free(&res);\n    }\n}\n\nbig_int *big_int_get_prime2(unsigned int len, unsigned int tst_cnt) {\n    int prime = 0;\n    big_int *res = (big_int *) malloc(sizeof(big_int));\n    res->length = len;\n    res->sign = '+';\n    big_int *two = big_int_get(\"10\");\n    res->number = (unsigned char *) calloc(res->length, sizeof(unsigned char));\n    res->number[len - 1] = 128;\n    res->number[0] = 1;\n    while ((!prime)&&(res->length!=len+1)) {\n        printf(\"%li\\n\", clock() / 1000000);\n        prime = big_int_primality_test(res, tst_cnt);\n        if (prime)return res;\n        big_int_add2(res, two);\n    }\n}\n\nbig_int *big_int_get_prime3(unsigned int len, unsigned int tst_cnt) {\n    int prime = 0;\n\n    big_int *two = big_int_get(\"10\");\n    while(1==1) {\n        big_int *res = big_int_rnd(len);\n        prime = big_int_primality_test(res, tst_cnt);\n        while ((!prime) && (res->length != len + 1)) {\n            printf(\"%li\\n\", clock() / 1000000);\n            prime = big_int_primality_test(res, tst_cnt);\n            if (prime)return res;\n            big_int_add2(res, two);\n        }\n        if (prime)return res;\n    }\n}\n\nvoid big_int_test_loop(long long n, int (*func)(big_int *, unsigned int)) {\n    int start = clock();\n    big_int *num1 = big_int_rnd(100);\n    for (long long i = 0; i < n; i++) {\n        func(num1, 20);    big_int *sq;\n\n//        big_int_free(t);\n    }\n    int end = clock();\n    printf(\"%f\\n\", (double) (end - start) / CLOCKS_PER_SEC);\n}\n\n\nbig_int *big_int_mul_inverse(const big_int *n1, big_int *mod) {\n\n    big_int *one= big_int_get(\"1\");\n    big_int *m_one= big_int_get(\"-1\");\n    big_int *gcd=big_int_euclid_binary(n1,mod);\n    if(!big_int_equal(gcd,one)){ big_int_free2(2,&gcd,&one); return m_one; }\n    big_int *x = big_int_get(\"1\");\n    big_int *y = big_int_get(\"0\");\n    big_int *x_next = big_int_get(\"0\");\n    big_int *y_next = big_int_get(\"1\");\n    big_int *a = big_int_copy(n1);\n    big_int *b = big_int_copy(mod);\n    big_int *zero = big_int_get(\"0\");\n    big_int *q = big_int_get(\"0\");\n\n    while (!big_int_leq(b, zero)) {\n\n        big_int_div3(a, b, q);//q=a/b\n\n        big_int *tmp1 = big_int_copy(b);//tmp=b\n\n        big_int_div2_for_pow(a, b, b);//b=a%b\n\n        big_int_swap(a, tmp1);//a=tmp\n        big_int_free2(1,&tmp1);\n\n        tmp1 = big_int_copy(x_next);//tmp=x_next\n\n        big_int *q_times_x_next = big_int_karatsuba_mult2(q, x_next);//x_next=x-q*x_next //x*=y\n        big_int_free(&x_next);\n        x_next = big_int_sub(x, q_times_x_next);\n\n        big_int_swap(x, tmp1);//x=tmp1\n        big_int_free2(2,&q_times_x_next,&tmp1);\n\n        tmp1 = big_int_copy(y_next);//tmp2=y_next\n\n        big_int *q_times_y_next = big_int_karatsuba_mult2(q, y_next);//y_next=y-q*y_next\n        big_int_free(&y_next);\n        y_next = big_int_sub(y, q_times_y_next);\n\n        big_int_swap(tmp1, y);//y=tmp2\n        big_int_free2(2,&q_times_y_next,&tmp1);\n    }\n    while(x->sign=='-'){\n        big_int_add2(x,mod);\n    }\n\n    big_int_free2(10,&y,&x_next,&y_next,&a,&b,&zero,&q,&one,&m_one,&gcd);\n    return x;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/big_int/big_int.c b/big_int/big_int.c
--- a/big_int/big_int.c	
+++ b/big_int/big_int.c	
@@ -90,7 +90,6 @@
 }
 
 void big_int_fprint(const big_int *n,FILE *f) {
-    putc(n->sign,f);
     for (int i = n->length - 1; i > -1; i--) {
         int x = n->number[i];
         int bit = 128;
